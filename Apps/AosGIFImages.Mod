(* ETH Oberon, Copyright 2001 ETH Zuerich Institut fuer Computersysteme, ETH Zentrum, CH-8092 Zuerich.
Refer to the "General ETH Oberon System Source License" contract available at: http://www.oberon.ethz.ch/ *)

MODULE AosGIFImages; (** non-portable *)	(* eos   **)
(** AUTHOR "eos"; PURPOSE "GIF image format"; *)

	(**
		Load GIF images (storing prohibited by Unisys patent)
	**)
	
	(*
		19.06.2000 - Aos version
	*)
	
	IMPORT
		SYSTEM, AosOut, AosIO, AosFS, AosCLUTs, Raster;
		
	VAR
		clut: POINTER TO AosCLUTs.CLUT;

	(*--- Image Format T8 (8 bit palette with transparent color 0) ---*)
	
	PROCEDURE PackT8 (VAR fmt: Raster.Format0; adr, bit: LONGINT; VAR pix: Raster.Pixel);
		CONST r = Raster.r; g = Raster.g; b = Raster.b;
	BEGIN
		IF pix[Raster.a] # 0X THEN
			SYSTEM.PUT(adr, CHR(Raster.PaletteIndex(fmt.pal, ORD(pix[r]), ORD(pix[g]), ORD(pix[b]))))
		ELSE
			SYSTEM.PUT(adr, 0X)
		END
	END PackT8;
	
	PROCEDURE UnpackT8 (VAR fmt: Raster.Format0; adr, bit: LONGINT; VAR pix: Raster.Pixel);
		CONST r = Raster.r; g = Raster.g; b = Raster.b; a = Raster.a;
		VAR idx: CHAR;
	BEGIN
		SYSTEM.GET(adr, idx);
		IF idx = 0X THEN
			pix[r] := 0X; pix[g] := 0X; pix[b] := 0X; pix[a] := 0X
		ELSE
			pix := fmt.pal.col[ORD(idx)]
		END
	END UnpackT8;
	
	
	(*--- GIF Loader ---*)
	
	PROCEDURE Log (msg: ARRAY OF CHAR);
	BEGIN
		AosOut.String("GIFImages: "); AosOut.String(msg); AosOut.Ln
	END Log;
	
	PROCEDURE LoadData (r: AosIO.Reader; img: Raster.Image; interlaced: BOOLEAN);
		VAR
			ch: CHAR;
			codeBits, clearCode, endCode, curBits, maxCode, nextCode, bits, x, y, lines, prevCode, curCode, seq, len: INTEGER;
			n, buf, blkPos, blkSize, ptr, bytesRead: LONGINT;
			pix, run: ARRAY 1000H OF CHAR;
			prev: ARRAY 1000H OF INTEGER;
			block: ARRAY 255 OF CHAR;
		
		PROCEDURE dot (pix: CHAR);
		BEGIN
			img.mem[ptr] := pix; INC(ptr); INC(x);
			IF x = img.width THEN
				IF interlaced THEN
					IF lines >= 8 THEN DEC(y, 8) ELSE DEC(y, lines) END;
					WHILE y < 0 DO
						lines := lines DIV 2; y := SHORT(img.height-1) - lines DIV 2
					END
				ELSE
					DEC(y)
				END;
				x := 0; ptr := y * img.bpr
			END
		END dot;
		
	BEGIN
		r.Char(ch); codeBits := ORD(ch);
		clearCode := SHORT(ASH(1, codeBits)); endCode := clearCode+1;
		n := 0;
		WHILE n < clearCode DO
			pix[n] := CHR(n); prev[n] := -1; INC(n)
		END;
		WHILE n <= endCode DO
			pix[n] := 0X; prev[n] := -1; INC(n)
		END;
		curBits := codeBits+1; maxCode := SHORT(ASH(1, curBits)); nextCode := endCode+1;
		buf := 0; bits := 0; blkPos := 0; blkSize := 0;	(* bit buffer and current block are empty *)
		x := 0; y := SHORT(img.height-1); ptr := y * img.bpr;
		IF interlaced THEN lines := 16 END;
		
		prevCode := clearCode;
		LOOP
			(* read next code *)
			WHILE bits < curBits DO	(* not enough bits available *)
				IF blkPos = blkSize THEN	(* at end of block *)
					r.Char(ch);
					IF ch = 0X THEN	(* terminator block mark *)
						Log("not enough image data"); RETURN
					END;
					blkPos := 0; blkSize := ORD(ch);
					r.Bytes(block, 0, blkSize, bytesRead)	(* ignore bytesRead *)
				END;
				buf := buf + ASH(ORD(block[blkPos]), bits); INC(blkPos); INC(bits, 8)
			END;
			curCode := SHORT(buf MOD maxCode);
			buf := ASH(buf, -curBits); DEC(bits, curBits);
			
			IF curCode = clearCode THEN
				curBits := codeBits+1; maxCode := SHORT(ASH(1, curBits)); nextCode := endCode+1
			ELSIF curCode = endCode THEN
				EXIT
			ELSIF prevCode = clearCode THEN
				dot(CHR(curCode)); seq := curCode
			ELSE
				IF curCode < nextCode THEN	(* reuse sequence *)
					seq := curCode; len := 0
				ELSE	(* append previous first char to previous sequence *)
					run[0] := pix[seq]; len := 1; seq := prevCode
				END;
				WHILE prev[seq] >= 0 DO
					run[len] := pix[seq]; INC(len); seq := prev[seq]
				END;
				dot(pix[seq]);
				WHILE len > 0 DO
					DEC(len); dot(run[len])
				END;
				
				(* the sequence just output gets a new code *)
				pix[nextCode] := pix[seq]; prev[nextCode] := prevCode; INC(nextCode);
				IF (nextCode = maxCode) & (curBits < 12) THEN
					INC(curBits); maxCode := SHORT(ASH(1, curBits))
				END
			END;
			prevCode := curCode
		END;
		
		(* search terminator block *)
		r.Char(ch);
		WHILE ch # 0X DO
			r.SkipBytes(ORD(ch));
			r.Char(ch)
		END
	END LoadData;
	
	PROCEDURE InitClut;
	VAR r: AosFS.Reader;
	BEGIN {EXCLUSIVE}
		IF clut = NIL THEN 
			NEW(clut);
			AosFS.OpenReader(r, AosFS.Old("AosDefault.Pal"), 0);
			AosCLUTs.Read(r, clut^, 256)
		END
	END InitClut;
	
	PROCEDURE Load (img: Raster.Image; VAR fname: ARRAY OF CHAR; VAR done: BOOLEAN);
		VAR
			file: AosFS.File; r: AosFS.Reader; sig: ARRAY 7 OF CHAR; w, h, images, left, top: INTEGER;
			lcdFlags, backGrndIdx, ch, label, transPix, idFlags: CHAR; pal: Raster.Palette; n, size, bytesRead: LONGINT;
			backGrndCol: Raster.Pixel; fmt: Raster.Format; transparent, interlaced: BOOLEAN;
			red, green, blue: LONGINT;
	BEGIN
		file := AosFS.Old(fname);
		IF file = NIL THEN RETURN END;
		
		(* check signature and version *)
		AosFS.OpenReader(r, file, 0);
		r.Bytes(sig, 0, 6, bytesRead); sig[6] := 0X;
		IF (sig # "GIF87a") & (sig # "GIF89a") THEN RETURN END;
		
		(* logical screen descriptor *)
		r.RawInt(w); r.RawInt(h);	(* dimensions of logical screen *)
		r.Char(lcdFlags); r.Char(backGrndIdx); r.Char(ch);	(* ignore aspect ratio *)
		
		(* set up default color table *)
		NEW(pal);
		InitClut;

		FOR n := 0 TO 255 DO
			red := ASH(clut.col[n], -16) MOD 100H;
			green := ASH(clut.col[n], -8) MOD 100H;
			blue := clut.col[n] MOD 100H;
			Raster.SetRGB(pal.col[n], red, green, blue)
		END;
		
		(* global color table *)
		IF ODD(ASH(ORD(lcdFlags), -7)) THEN
			n := 0; size := ASH(1, 1 + ORD(lcdFlags) MOD 8);
			WHILE n < size DO
				r.Char(pal.col[n, Raster.r]); r.Char(pal.col[n, Raster.g]);
				r.Char(pal.col[n, Raster.b]); pal.col[n, Raster.a] := 0FFX;
				INC(n)
			END;
			backGrndCol := pal.col[ORD(backGrndIdx)]
		ELSE
			Raster.SetRGB(backGrndCol, 0C0H, 0C0H, 0C0H)	(* color 14 in Oberon standard palette, used for text background *)
		END;
		Raster.InitPaletteFormat(fmt, pal);
		
		images := 0; transparent := FALSE;
		LOOP
			r.Char(ch);
			IF r.res # AosIO.Ok THEN
				Log("unexpected end of file"); RETURN
			ELSIF ch = 3BX THEN	(* trailer *)
				EXIT
			ELSIF ch = 21X THEN	(* extension introducer *)
				r.Char(label); r.Char(ch);	(* extension label and block size *)
				IF label = 0F9X THEN	(* graphic control block *)
					IF ch # 4X THEN Log("graphic control extension block size # 4"); RETURN END;
					r.Char(ch); transparent := ODD(ORD(ch));
					r.SkipBytes(2); r.Char(transPix);
					IF transparent THEN
						Raster.InitFormat(fmt, Raster.custom, 8, 1, {Raster.index, Raster.alpha}, pal, PackT8, UnpackT8)
					END;
					r.Char(ch)	(* read next block size (should be zero) *)
				END;
				WHILE ch # 0X DO	(* skip data blocks *)
					r.SkipBytes(ORD(ch)); r.Char(ch)
				END
			ELSIF ch = 2CX THEN	(* image descriptor *)
				INC(images);
				IF images > 1 THEN
					Log("ignoring all but first image"); EXIT
				END;
				r.RawInt(left); r.RawInt(top);
				r.RawInt(w); r.RawInt(h);
				r.Char(idFlags);
				interlaced := ODD(ASH(ORD(idFlags), -6));
				
				(* local color table *)
				IF ODD(ASH(ORD(idFlags), -7)) THEN
					n := 0; size := ASH(1, 1 + ORD(idFlags) MOD 8);
					WHILE n < size DO
						r.Char(pal.col[n, Raster.r]); r.Char(pal.col[n, Raster.g]); r.Char(pal.col[n, Raster.b]);
						INC(n)
					END
				END;
				
				(* create image and load image data *)
				Raster.Create(img, w, h, fmt);
				LoadData(r, img, interlaced);
				
				IF transparent THEN	(* ensure that transparent color has index 0 *)
					IF transPix # 0X THEN
						pal.col[ORD(transPix)] := pal.col[0];
						n := 0;
						WHILE n < LEN(img.mem^) DO
							IF img.mem[n] = 0X THEN img.mem[n] := transPix
							ELSIF img.mem[n] = transPix THEN img.mem[n] := 0X
							END;
							INC(n)
						END
					END;
					pal.col[0] := backGrndCol
				END;
				
				(* don't forget to initialize the palette *)
				Raster.InitPalette(pal, SHORT(size), 4)
			ELSE
				Log("confused by unknown block type"); RETURN
			END
		END;
		
		done := images > 0	(* successful if image has been read *)
	END Load;
	
	PROCEDURE AosLoad*(x: PTR) : PTR;
	BEGIN
		IF x IS Raster.PictureTransferParameters THEN WITH x:Raster.PictureTransferParameters DO
			Load(x.img, x.name, x.done);
			Raster.Init(x.img, x.img.width, x.img.height, x.img.fmt, -x.img.bpr, SYSTEM.ADR(x.img.mem[0]) + (x.img.height-1)*x.img.bpr);
		END END;	
		RETURN NIL
	END AosLoad;
	
END AosGIFImages.
